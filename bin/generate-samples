#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate sample page images for documentation
#
# This script:
# 1. Generates a PDF planner for the current year
# 2. Extracts one page of each page type as PNG images
# 3. Saves images to docs/ folder for README reference

require 'fileutils'
require 'date'

YEAR = Date.today.year
PDF_FILE = "planner_#{YEAR}.pdf"
DOCS_DIR = File.expand_path('../docs', __dir__)
DPI = 150  # Resolution for PNG output

# Page numbers (1-indexed as they appear in PDF)
# Negative numbers count from end: -1 = last, -2 = second to last, etc.
PAGES = {
  'seasonal_calendar' => 1,
  'year_events' => 2,
  'multi_year_overview' => 4,
  'weekly' => 10,           # Pick a week in the middle
  'grid_showcase' => -11,   # First grid page (8 grids + 3 templates from end)
  'reference' => -3,        # Calibration page
  'daily_wheel' => -2,      # Daily wheel template
  'year_wheel' => -1        # Year wheel template (last page)
}

puts "Generating sample images for planner documentation..."
puts

# Step 1: Generate the PDF
puts "1. Generating PDF for #{YEAR}..."
system("bundle exec bin/bujo-pdf #{YEAR}") || abort("Failed to generate PDF")
abort("PDF file not found: #{PDF_FILE}") unless File.exist?(PDF_FILE)
puts "   ✓ Generated #{PDF_FILE}"
puts

# Step 2: Create docs directory
FileUtils.mkdir_p(DOCS_DIR)
puts "2. Creating docs directory..."
puts "   ✓ #{DOCS_DIR}"
puts

# Step 3: Get total page count
# Try pdfinfo first, fall back to pdftk, then to hardcoded value
page_count = nil
if system("which pdfinfo > /dev/null 2>&1")
  page_count = `pdfinfo #{PDF_FILE} 2>/dev/null | grep Pages | awk '{print $2}'`.strip.to_i
elsif system("which pdftk > /dev/null 2>&1")
  page_count = `pdftk #{PDF_FILE} dump_data 2>/dev/null | grep NumberOfPages | awk '{print $2}'`.strip.to_i
end
page_count = 68 if page_count.nil? || page_count == 0  # Fallback for 2025
puts "3. PDF has #{page_count} pages"
puts

# Step 4: Extract pages to PNG
puts "4. Extracting sample pages..."
PAGES.each do |name, page_num|
  output_file = File.join(DOCS_DIR, "#{name}.png")

  # Convert negative page numbers to actual page numbers
  actual_page = if page_num < 0
                  page_count + page_num + 1  # -1 becomes last, -2 becomes second to last
                else
                  page_num
                end

  # Use pdftoppm (poppler) for conversion - more commonly available than ImageMagick
  # pdftoppm uses 1-indexed pages, outputs to stdout with -png flag
  output_base = output_file.sub(/\.png$/, '')
  cmd = "pdftoppm -png -r #{DPI} -f #{actual_page} -l #{actual_page} -singlefile #{PDF_FILE} #{output_base}"

  print "   Extracting page #{actual_page} (#{name})... "
  system(cmd, err: File::NULL) || abort("\n   ✗ Failed to convert #{name}")
  puts "✓"
end
puts

# Step 5: Show results
puts "5. Results:"
PAGES.keys.each do |name|
  file_path = File.join(DOCS_DIR, "#{name}.png")
  size_kb = (File.size(file_path) / 1024.0).round(1)
  puts "   ✓ #{name}.png (#{size_kb} KB)"
end
puts

puts "Sample images saved to: #{DOCS_DIR}"
puts
puts "You can now reference these in README.md:"
PAGES.keys.each do |name|
  puts "![#{name.split('_').map(&:capitalize).join(' ')}](docs/#{name}.png)"
end
